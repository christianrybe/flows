<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );








    </script>
    <style>
        body {
            background: url( 'images/stars.jpg' ) no-repeat center center fixed;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
        }








    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section><h2>Flows - Kotlin's shot at concurrency</h2></section>
        <section data-background-image="images/mars.png">
            <aside class="notes">
                It’s the year 2047. Mark is the captain of Leto II - the second mission to Mars. The first expedition
                disappeared mysteriously having launched from Phobos - one of Mars satellites - to land on the Red
                Planet. Mark has lead his team from the moon with no complications and that’s what worries him most. He
                hoped he would encounter some problems that could lead him to what happened to Leto I.
            </aside>
        </section>
        <section data-background-image="images/phobos.jpg">
            <aside class="notes">
                Now that he has traced their path all the way to Phobos and it’s time to leave the Red Rock he feels
                really uneasy. He should know what issues Leto I was facing, but he has seen no sign of them so far.
                He’s now ordering to launch the engines and hopes there won’t be any unforeseen complications… Leto II
                is travelling aboard a large carrier equipped with large engines. They take quite a while to launch and
                they also have an autocleaning function that preserves all the elements of the propulsion system. Both
                starting the engines and doing the auto cleaning takes quite a while and so it’s started asynchronously
                by the spacecraft driver. This is the same code that Leto I used:
            </aside>
        </section>
        <section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startEngines(): CompletableFuture&lt;Int&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting engines from Completable Future")
                            Thread.sleep(700) //heavy work
                            120
                        }
                    }</code></pre>
                <aside class="notes">
                    We have here two async functions using Completable Future to spin off async tasks.
                </aside>
            </section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startAutoCleaning(): CompletableFuture&lt;Boolean&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting cleaning from Completable Future")
                            Thread.sleep(500) //takes a while too
                            throw RuntimeException()
                        }
                    }</code></pre>
            </section>
            <section>
            <pre><code class="kotlin" data-trim data-noescape data-line-numbers>
                fun initiateStart() {
                    val engineFuture = spaceship.startEngines()
                    val cleaningFuture = spaceship.startAutoCleaning()

                    spaceship.setOff(engineFuture.get())
                }
			</code></pre>
                <aside class="notes">

                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                fun initiateStart() {
                    val engineFuture = spaceship.startEngines()
                    val cleaningFuture = spaceship.startAutoCleaning()

                    spaceship.setOff(engineFuture.get())
                    reportCleaning(cleaningFuture.get())
                }
                </code>
            </pre>
                <aside class="notes">
                    And then we have the driver code that uses them.
                    This looks more or less fine, right? Cleaning takes a while
                    so I want to kick it off in another thread and I want to happen while the engines are starting to
                    save some time. When the engines are on, the we're gonna
                    set off with the speed reported by the engines.
                    The problem is that futures are known as hot sources. They are like resources, IO for example - they
                    need to be closed
                    whether on completion or when
                    an error occurs. Here, when these futures are unrelated two bad things may happen.
                    Firstly: if cleaningFuture fails, then we have lost
                    reference to engineFuture and it continues to work in the background consuming resources. Second of
                    all if it so happens that engineFuture also fails, then we cannot handle the failure in any way.
                </aside>
            </section>
            <section>
                <pre><code class="hljs" data-trim data-noescape>
                Starting engines from Completable Future
                Futures started!
                Starting cleaning from Completable Future
                <span class="fragment fade-in">
                Spaceship is taking off with speed: 120
                java.util.concurrent.ExecutionException: java.lang.RuntimeException
                at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
                at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
                </span>
                <span class="fragment fade-in">
                //Cleaning system failure sets the engines on fire
                //when the spaceship has already set off!
                </span>
                </code></pre>
                <aside class="notes">
                    It seems that we have solved the mystery of Leto I.
                    Careless handling of asynchronous tasks led
                    to a true disaster. Failure in the cle How can Mark solve this issue and not get his spaceship blown
                    up?
                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                    fun initiateStart() {
                       spaceship
                        .startEngines()
                        .thenCombine(spaceship.startAutoCleaning()) {
                            speed, two ->
                                spaceship.setOff(speed)
                                two
                        }
                        .whenComplete { result, failure ->
                            if (failure == null) reportCleaning(result)
                        }
                    }
                </code>
            </pre>
                <aside class="notes">
                    One possible solution to this problem is using <b>combinators</b>. They basically allow you to
                    combine multiple futures and handles failures properly. And that is more or less fine actually.
                    But... there always is a but :) This looks horrible for me. Second of all you really need
                    to go deep into this combinators business. And I really don't want that. I just wanted
                    to spin off some async tasks and not mess around with combinators. Now your async code looks
                    very different to your async code, which is not nice at all. You are also lucky if there is a
                    combinator for the problem you are facing and you can find it.
                </aside>
            </section>
        </section>
        <section>
            <h3>Kotlin Coroutines</h3>
            <h3>to the rescue!</h3>
            <aside class="notes">
                How is this going to help Mark not get blown up or how is this going to help you write code
                you are familiar with?
            </aside>
        </section>
        <!--        <section>-->
        <!--            <pre>-->
        <!--                <code class="kotlin" dat-trim data-noescape>-->
        <!--                    -->
        <!--                </code>-->
        <!--            </pre>-->
        <!--        <aside class="notes">-->

        <!--        </aside>-->
        <!--        </section>-->
    </div>
</div>

<script src="js/reveal.js"></script>

<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
			    progress: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});



</script>
</body>
</html>
