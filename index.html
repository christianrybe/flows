<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );



    </script>
    <style>
        body {
            background: url( 'images/stars.jpg' ) no-repeat center center fixed;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
        }



    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section><h2>Flows - Kotlin's shot at concurrency</h2></section>
        <section data-background-image="images/mars.png">
            <aside class="notes">
                It’s the year 2047. Mark is the captain of Leto II - the second mission to Mars. The first expedition
                disappeared mysteriously having launched from Phobos - one of Mars satellites - to land on the Red
                Planet. Mark has lead his team from the moon with no complications and that’s what worries him most. He
                hoped he would encounter some problems that could lead him to what happened to Leto I.
            </aside>
        </section>
        <section data-background-image="images/phobos.jpg">
            <aside class="notes">
                Now that he has traced their path all the way to Phobos and it’s time to leave the Red Rock he feels
                really uneasy. He should know what issues Leto I was facing, but he has seen no sign of them so far.
                He’s now ordering to launch the engines and hopes there won’t be any unforeseen complications… Leto II
                is travelling aboard a large carrier equipped with large engines. They take quite a while to launch and
                they also have an autocleaning function that preserves all the elements of the propulsion system. Both
                starting the engines and doing the auto cleaning takes quite a while and so it’s started asynchronously
                by the spacecraft driver. This is the same code that Leto I used:
            </aside>
        </section>
        <section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startEngines(): CompletableFuture&lt;Int&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting engines from Completable Future")
                            Thread.sleep(700) //heavy work
                            120
                        }
                    }</code></pre>
                <aside class="notes">
                    We have here two async functions using Completable Future to spin off async tasks.
                </aside>
            </section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startAutoCleaning(): CompletableFuture&lt;Boolean&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting cleaning from Completable Future")
                            Thread.sleep(500) //takes a while too
                            throw RuntimeException()
                        }
                    }</code></pre>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                fun initiateStart() {
                    val engineFuture = spaceship.startEngines()
                    val cleaningFuture = spaceship.startAutoCleaning()

                    spaceship.setOff(engineFuture.get())
                    reportCleaning(cleaningFuture.get())
                }
                </code>
            </pre>
                <aside class="notes">
                    And then we have the driver code that uses them.
                    This looks more or less fine, right? Cleaning takes a while
                    so I want to kick it off in another thread and I want to happen while the engines are starting to
                    save some time. When the engines are on, the we're gonna
                    set off with the speed reported by the engines.
                    The problem is that futures are known as hot sources. They are like resources, IO for example - they
                    need to be closed
                    whether on completion or when
                    an error occurs. Here, when these futures are unrelated two bad things may happen.
                    Firstly: if cleaningFuture fails, then we have lost
                    reference to engineFuture and it continues to work in the background consuming resources. Second of
                    all if it so happens that engineFuture also fails, then we cannot handle the failure in any way.
                </aside>
            </section>
            <section>
                <pre><code class="plaintext" data-trim data-noescape>
                Starting engines from Completable Future
                Futures started!
                Starting cleaning from Completable Future
                <span class="fragment fade-in">
                Spaceship is taking off with speed: 120
                java.util.concurrent.ExecutionException: java.lang.RuntimeException
                at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
                at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
                //Cleaning system failure sets the engines on fire
                //when the spaceship has already set off!
                </span>
                </code></pre>
                <aside class="notes">
                    Let's see what happens when we run this code.
                    We see that code is indeed executed async, because the logs are not printed sequentially.
                    And then what happens when the futures are actually executed?
                    Engines complete successfully, but cleaning fails and this failure is not handled properly.
                    We see fire in the cleaning system, but can't do anything about it and the spaceship sets of
                    anyway. It seems that we have solved the mystery of Leto I.
                    Careless handling of asynchronous tasks led
                    to a true disaster. Can Mark solve this issue and not get his spaceship blown up?
                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                    fun initiateStart() {
                        reportCleaning(
                            spaceship
                                .startEngines()
                                .thenCombine(spaceship.startAutoCleaning())
                                { speed, isCleaningOk ->
                                    spaceship.setOff(speed)
                                    isCleaningOk
                                }
                                .get()
                        )
                    }
                </code>
            </pre>
                <aside class="notes">
                    One possible solution to this problem is using <b>combinators</b>. They basically allow you to
                    combine multiple futures and handles failures properly.
                </aside>
            </section>
            <section>
                <pre><code class="plaintext" data-trim data-noescape>
                Starting engines from Completable Future
                Starting cleaning from Completable Future
                java.util.concurrent.ExecutionException: java.lang.RuntimeException
                at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
                at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
                </code></pre>
                <aside class="notes">
                    And that is more or less fine actually. When any of the future completes exceptionally then
                    the entire combinator is cancelled.
                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                    fun initiateStart() {
                        reportCleaning(
                            spaceship
                                .startEngines()
                                .thenCombine(spaceship.startAutoCleaning())
                                { speed, isCleaningOk ->
                                    spaceship.setOff(speed)
                                    isCleaningOk
                                }
                                .get()
                        )
                    }
                </code>
            </pre>
                <aside class="notes">
                    But... there always is a but :) This looks horrible for me. I mean look at this code!
                    Can you read it for the first time and see what it's doing? I don't even though I wrote it!
                    It's like ''a joke here''
                    Second of all you really need
                    to go deep into this combinators business. And I really don't want that. I just wanted
                    to spin off some async tasks and not mess around with combinators. Now your async code looks
                    very different to your async code, which is not nice at all. You are also lucky if there is a
                    combinator for the problem you are facing and you can find it.
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3>Kotlin Coroutines</h3>
                <h3>to the rescue!</h3>
                <aside class="notes">
                    How is this going to help Mark not get blown up or how is this going to help you write code
                    you are familiar with?
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        suspend fun startEngines(): Int {
                            println("Starting engines")
                            delay(700)
                            return 190
                        }
                    </code>
                </pre>
                <aside class="notes">
                    We will first simplify the the spaceship functions. Instead of using Completable
                    Futures they will be declared as suspending functions and will simply return their values.
                    A suspending function is simply a function which execution can be paused and resumed later
                    without blocking the calling thread. How this is done is these suspend functions are compiled
                    to functions with a callback parameter which is used to resume the execution of the function.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        suspend fun autoClean(): Boolean {
                            println("Starting cleaning")
                            delay(500)
                            throw RuntimeException()
                        }
                    </code>
                </pre>
                <aside class="notes">
                    And we also change the second function to a suspending function.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                    suspend fun initiateStart() = coroutineScope {
                        val engineDeferred = async { suspendingShip.startEngines() }
                        val cleaningDeferred = async { suspendingShip.autoClean() }

                        println("Coroutines started!")

                        spaceship.setOff(engineDeferred.await())
                        reportCleaning(cleaningDeferred.await())
                    }
                    </code>
                </pre>
                <aside class="notes">
                    With Kotlin coroutines we can write the code like it was ordinary sequential code. We can almost go
                    back to our first attempt and this time it is going to be correct. It's sup

                    We keep the same logic, but wrap it in a coroutineScope. What this does is it creates
                    a ContextScope and executes the provided block of code in a new coroutine. You can basically think
                    of coroutines as lightweight threads. So lightweight in fact that you are encouraged to create
                    a lot of them in your concurrent applications.
                    A slight difference to the code that we had before is that we are not wrapping
                </aside>
            </section>
        </section>
        <!--        <section>-->
        <!--            <pre>-->
        <!--                <code class="kotlin" data-trim data-noescape>-->
        <!--                    -->
        <!--                </code>-->
        <!--            </pre>-->
        <!--        <aside class="notes">-->

        <!--        </aside>-->
        <!--        </section>-->
    </div>
</div>

<script src="js/reveal.js"></script>

<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
			    progress: false,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true }
				]
			});







</script>
</body>
</html>
