<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );

    </script>
    <style>body {
            background: url( 'images/stars.jpg' ) no-repeat center center fixed;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section><h2>Flows - Kotlin's shot at concurrency</h2></section>
        <section data-background-image="images/mars.png">
            <aside class="notes">
                It’s the year 2047. Mark is the captain of Leto II - the second mission to Mars. The first expedition
                disappeared mysteriously having launched from Phobos - one of Mars satellites - to land on the Red
                Planet. Mark has lead his team from the moon with no complications and that’s what worries him most. He
                hoped he would encounter some problems that could lead him to what happened to Leto I.
            </aside>
        </section>
        <section data-background-image="images/phobos.jpg">
            <aside class="notes">
                Now that he has traced their path all the way to Phobos and it’s time to leave the Red Rock he feels
                really uneasy. He should know what issues Leto I was facing, but he has seen no sign of them so far.
                He’s now ordering to launch the engines and hopes there won’t be any unforeseen complications… Leto II
                is travelling aboard a large carrier equipped with large engines. They take quite a while to launch and
                they also have an autocleaning function that preserves all the elements of the propulsion system. Both
                starting the engines and doing the auto cleaning takes quite a while and so it’s started asynchronously
                by the spacecraft driver. This is the same code that Leto I used:
            </aside>
        </section>
        <section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startEngines(): CompletableFuture&lt;Int&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting engines from Completable Future")
                            Thread.sleep(700) //heavy work
                            120
                        }
                    }</code></pre>
                <aside class="notes">
                    We have here two async functions using Completable Future to spin off async tasks.
                </aside>
            </section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startAutoCleaning(): CompletableFuture&lt;Boolean&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting cleaning from Completable Future")
                            Thread.sleep(500) //takes a while too
                            throw RuntimeException()
                        }
                    }</code></pre>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                fun initiateStart() {
                    val engineFuture = spaceship.startEngines()
                    val cleaningFuture = spaceship.startAutoCleaning()

                    println("Futures started!")

                    spaceship.setOff(engineFuture.get())
                    reportCleaning(cleaningFuture.get())
                }
                </code>
            </pre>
                <aside class="notes">
                    And then we have the driver code that uses them.
                    This looks more or less fine, right? Cleaning takes a while
                    so I want to kick it off in another thread and I want to happen while the engines are starting to
                    save some time. When the engines are on, the we're gonna
                    set off with the speed reported by the engines.
                    The problem is that futures are known as hot sources. They are like resources, IO for example - they
                    need to be closed
                    whether on completion or when
                    an error occurs. Here, when these futures are unrelated two bad things may happen.
                    Firstly: if cleaningFuture fails, then we have lost
                    reference to engineFuture and it continues to work in the background consuming resources. Second of
                    all if it so happens that engineFuture also fails, then we cannot handle the failure in any way.
                </aside>
            </section>
            <section>
                <pre><code class="plaintext" data-trim data-noescape>
                Starting engines from Completable Future
                Futures started!
                Starting cleaning from Completable Future
                <span class="fragment fade-in">
                Spaceship is taking off with speed: 120
                java.util.concurrent.ExecutionException: java.lang.RuntimeException
                at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
                at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
                //Cleaning system failure sets the engines on fire
                //when the spaceship has already set off!
                </span>
                </code></pre>
                <aside class="notes">
                    Let's see what happens when we run this code.
                    We see that code is indeed executed async, because the logs are not printed sequentially.
                    And then what happens when the futures are actually executed?
                    Engines complete successfully, but cleaning fails and this failure is not handled properly.
                    We see fire in the cleaning system, but can't do anything about it and the spaceship sets of
                    anyway. It seems that we have solved the mystery of Leto I.
                    Careless handling of asynchronous tasks led
                    to a true disaster. Can Mark solve this issue and not get his spaceship blown up?
                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                    fun initiateStart() {
                        reportCleaning(
                            spaceship
                                .startEngines()
                                .thenCombine(spaceship.startAutoCleaning())
                                { speed, isCleaningOk ->
                                    spaceship.setOff(speed)
                                    isCleaningOk
                                }
                                .get()
                        )
                    }
                </code>
            </pre>
                <aside class="notes">
                    One possible solution to this problem is using <b>combinators</b>. They basically allow you to
                    combine multiple futures and handles failures properly.
                </aside>
            </section>
            <section>
                <pre><code class="plaintext" data-trim data-noescape>
                Starting engines from Completable Future
                Starting cleaning from Completable Future
                java.util.concurrent.ExecutionException: java.lang.RuntimeException
                at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
                at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
                </code></pre>
                <aside class="notes">
                    And that is more or less fine actually. When any of the future completes exceptionally then
                    the entire combinator is cancelled.
                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                    fun initiateStart() {
                        reportCleaning(
                            spaceship
                                .startEngines()
                                .thenCombine(spaceship.startAutoCleaning())
                                { speed, isCleaningOk ->
                                    spaceship.setOff(speed)
                                    isCleaningOk
                                }
                                .get()
                        )
                    }
                </code>
            </pre>
                <aside class="notes">
                    But... there always is a but :) This looks horrible for me. I mean look at this code!
                    Can you read it for the first time and see what it's doing? I don't even though I wrote it!
                    It's like ''a joke here''
                    Second of all you really need
                    to go deep into this combinators business. And I really don't want that. I just wanted
                    to spin off some async tasks and not mess around with combinators. Now your async code looks
                    very different to your async code, which is not nice at all. You are also lucky if there is a
                    combinator for the problem you are facing and you can find it.
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3>Kotlin Coroutines</h3>
                <h3>to the rescue!</h3>
                <aside class="notes">
                    How is this going to help Mark not get blown up or how is this going to help you write code
                    you are familiar with?
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        suspend fun startEngines(): Int =
                            withContext(Dispatchers.IO) {
                                println("Starting engines")
                                delay(700)
                                190
                            }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="2"/>
                <aside class="notes">
                    We will first modify the the spaceship functions. Instead of using Completable
                    Futures they will be declared as suspending functions and will simply return their values.
                    However we don't want to only declare them as suspending, but we actually want to make them
                    suspending. What does that even mean?
                    A suspending function is simply a function which execution can be paused and resumed later
                    without blocking the calling thread. How is this done? These suspend functions are compiled
                    to functions with a callback parameter which is used to resume the execution of the function.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        suspend fun startEngines(callback: Continuation&lt;Int&gt;): Int =
                            withContext(Dispatchers.IO) {
                                println("Starting engines")
                                delay(700)
                                190
                            }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="1">
                    <i>callback</i> is used to resume computation.
                </p>
                <aside class="notes"></aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        suspend fun autoClean(): Boolean =
                           withContext(Dispatchers.IO) {
                               println("Starting cleaning")
                               delay(500)
                               throw RuntimeException()
                           }
                    </code>
                </pre>
                <aside class="notes">
                    And we also change the second function to a suspending function.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                    suspend fun initiateStart() = coroutineScope {
                        val engineDeferred = async { suspendingShip.startEngines() }
                        val cleaningDeferred = async { suspendingShip.autoClean() }

                        println("Coroutines started!")

                        spaceship.setOff(engineDeferred.await())
                        reportCleaning(cleaningDeferred.await())
                    }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="1"/>
                <p class="fragment" data-code-focus="2,3"/>
                <aside class="notes">
                    With Kotlin coroutines we can write the code like it was ordinary sequential code. We can almost go
                    back to our first attempt and this time it is going to be correct. It's very easy to write and
                    super readable. We keep almost the same logic, but wrap it in a coroutineScope and async modifiers.

                    Concurrency in Kotlin just like the entire language is very explicit. The way it works here is that
                    we create a CoroutineScope at the very top, which wraps all the computation that we want to
                    decompose in parallel.
                    I don't want to go super deep in here, but slightly simplifying:
                    This guy has two important properties: first of all by convention each scope waits for all its
                    children to finish, so that we can reason about it in a sequential manner. And second of all scopes
                    are used to propagate cancellation to its children not to leave any hanging computation.
                    We are allowed to launch coroutines only in a Coroutine Scope. Why? Because Kotlin wants us to run
                    the concurrent computation in a well-defined context. You often want to spin off some concurrent
                    computation only in a limited time frame and then clean up. This is what Coroutine Scope is
                    essentially for.
                    It is an entity with a well-defined lifecycle which is responsible for launching and cancelling
                    children coroutines.

                    Now: what are these coroutines and where are they? Well, they're right here! You can think of
                    coroutines as lightweight threads. So lightweight in fact that you should not be afraid creating
                    them, but you're actually encouraged to create many of them to structure your concurrent logic.
                    Which I guess is kind of exemplified by how easy it is to create and use them.

                    Async is an extension method on CoroutineScope. Don't worry if you don't know what that is. It
                    basically operates on the coroutine scope we created here. async{} creates a new coroutine and
                    it returns its future result as an implementation of Deferred, which is kind of Kotlin equivalent of
                    Java Future. This is one of Kotlin coroutine builders and what they also do is they create their
                    own CoroutineScope, which allows them to launch their children computation. Let's not go too deep
                    into the rabbit hole, but I hope you get the idea.
                </aside>
            </section>
            <section>
                <aside class="notes">

                    What this does is it creates a CoroutineScope and executes the provided block of code in a
                    new coroutine. You can basically think
                    of coroutines as lightweight threads. So lightweight in fact that you are encouraged to create
                    a lot of them in your concurrent applications.
                    A slight difference to the code that we had before is that we are not wrapping
                </aside>
            </section>
        </section>
        <!--        <section>-->
        <!--            <pre>-->
        <!--                <code class="kotlin" data-trim data-noescape>-->
        <!--                    -->
        <!--                </code>-->
        <!--            </pre>-->
        <!--        <aside class="notes">-->

        <!--        </aside>-->
        <!--        </section>-->
    </div>
</div>

<script src="js/reveal.js"></script>

<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
			    progress: false,
			    history: true,
			    slideNumber: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'node_modules/reveal-code-focus/reveal-code-focus.js',
                      async: true,
                      callback: function() {
                        RevealCodeFocus();
                      }
                    }
				]
			});

</script>
</body>
</html>
