<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>Flows - Kotlin's shot at concurrency</title>

    <link rel="stylesheet" href="css/reset.css">
    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/night.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="lib/css/monokai.css">

    <!-- Printing and PDF exports -->
    <script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );


    </script>
    <style>body {
            background: url( 'images/stars.jpg' ) no-repeat center center fixed;
            -webkit-background-size: cover;
            -moz-background-size: cover;
            -o-background-size: cover;
            background-size: cover;
        }


    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section><h2>Flows - Kotlin's shot at concurrency</h2>
        <aside class="notes">
            Thanks for coming guys, I hope that I will get that many ppl at the conference in Kraków and that there will
            be more ppl than just the camera guy. But anyway it’s very good to
            see you. I’m glad that you ppl are interested in Flows because it is a pretty cool thing. Even better:
            it is a cherry on top of a really cool thing, but first I’d like to tell you the story of Mark

            I had this talk at Codete Lublin office last week to practice and 5 ppl came. I asked them if they have
            any friends in Krakow so that at least as many ppl would come here but look at you. It’s very good to
            see you. I’m glad that you ppl are interested in Flows because it is a pretty cool thing. Even better:
            it is a cherry on top of a really cool thing, but first I’d like to tell you the story of Mark
        </aside>
        </section>
        <section data-background-image="images/mars.png">
            <aside class="notes">
                I'm gonna tell you the story of Mark, which hopefully is gonna be less tragic than Tony Stark from
                the Avengers, I hoped I haven't spoiled if someone hasn't seen it yet.
                It’s the year 2047. Mark is the captain of Leto II - the second mission to Mars. The first expedition
                disappeared mysteriously having launched from Phobos - one of Mars satellites - to land on the Red
                Planet. Mark has lead his team from the moon with no complications and that’s what worries him most. He
                hoped he would encounter some problems that could lead him to what happened to Leto I.
            </aside>
        </section>
        <section data-background-image="images/phobos.jpg">
            <aside class="notes">
                Now that he has traced their path all the way to Phobos and it’s time to leave the Red Rock he feels
                really uneasy. He should know what issues Leto I was facing, but he has seen no sign of them so far.
                He’s now ordering to launch the engines and hopes there won’t be any unforeseen complications… Leto II
                is travelling aboard a large carrier equipped with large engines. They take quite a while to launch and
                they also have an autocleaning function that preserves all the elements of the propulsion system. Both
                starting the engines and doing the auto cleaning takes quite a while and so it’s started asynchronously
                by the spacecraft driver. This is the same code that Leto I used:
            </aside>
        </section>
        <section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startEngines(): CompletableFuture&lt;Int&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting engines from Completable Future")
                            Thread.sleep(700) //heavy work
                            120
                        }
                    }</code></pre>
                <aside class="notes">
                    We have here two async functions using Completable Future to spin off async tasks.
                </aside>
            </section>
            <section>
                <pre><code class="kotlin" data-trim>
                    fun startAutoCleaning(): CompletableFuture&lt;Boolean&gt; {
                        return CompletableFuture.supplyAsync {
                            println("Starting cleaning from Completable Future")
                            Thread.sleep(500) //takes a while too
                            throw RuntimeException()
                        }
                    }</code></pre>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                fun initiateStart() {
                    val engineFuture = spaceship.startEngines()
                    val cleaningFuture = spaceship.startAutoCleaning()

                    println("Futures started!")

                    spaceship.setOff(engineFuture.get())
                    spaceship.reportCleaning(cleaningFuture.get())
                }
                </code>
            </pre>
                <aside class="notes">
                    And then we have the driver code that uses them.
                    This looks more or less fine, right? Cleaning takes a while
                    so I want to kick it off in another thread and I want to happen while the engines are starting to
                    save some time. When the engines are on, the we're gonna
                    set off with the speed reported by the engines.
                    The problem is that futures are known as hot sources. They are like resources, IO for example - they
                    need to be closed
                    whether on completion or when
                    an error occurs. Here, when these futures are unrelated two bad things may happen.
                    Firstly: if cleaningFuture fails, then we have lost
                    reference to engineFuture and it continues to work in the background consuming resources. Second of
                    all if it so happens that engineFuture also fails, then we cannot handle the failure in any way.
                </aside>
            </section>
            <section>
                <pre><code class="plaintext stretch" data-trim data-noescape>
                Starting engines from Completable Future
                Futures started!
                Starting cleaning from Completable Future
                <p class="fragment fade-in">
                Spaceship is taking off with speed: 120
                </p>
                <p class="fragment fade-in">
                java.util.concurrent.ExecutionException: java.lang.RuntimeException
                at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
                at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
                </p>
                <p class="fragment fade-in">
                //Cleaning system failure sets the engines on fire
                //but the spaceship sets off regardless!
                </p>
                </code></pre>
                <aside class="notes">
                    Let's see what happens when we run this code.
                    We see that code is indeed executed async, because the logs are not printed sequentially.
                    And then what happens when the futures are actually executed?
                    Engines complete successfully, but cleaning fails and this failure is not handled properly.
                    We see fire in the cleaning system, but can't do anything about it and the spaceship sets of
                    anyway. It seems that we have solved the mystery of Leto I.
                    Careless handling of asynchronous tasks led
                    to a true disaster. Can Mark solve this issue and not get his spaceship blown up?
                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                    fun initiateStart() {
                        spaceship.reportCleaning(
                            spaceship.startEngines()
                                .thenCombine(spaceship.startAutoCleaning())
                                { speed, isCleaningOk ->
                                    spaceship.setOff(speed)
                                    isCleaningOk
                                }
                                .get()
                        )
                    }
                </code>
            </pre>
                <aside class="notes">
                    One possible solution to this problem is using <b>combinators</b>. They basically allow you to
                    combine multiple futures and handles failures properly.
                </aside>
            </section>
            <section>
                <pre><code class="plaintext" data-trim data-noescape>
                Starting engines from Completable Future
                Starting cleaning from Completable Future
                java.util.concurrent.ExecutionException: java.lang.RuntimeException
                at java.base/java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:395)
                at java.base/java.util.concurrent.CompletableFuture.get(CompletableFuture.java:1999)
                </code></pre>
                <aside class="notes">
                    And that is more or less fine actually. When any of the future completes exceptionally then
                    the entire combinator is cancelled.
                </aside>
            </section>
            <section>
            <pre>
                <code class="kotlin" data-trim data-noescape>
                    fun initiateStart() {
                        spaceship.reportCleaning(
                            spaceship.startEngines()
                                .thenCombine(spaceship.startAutoCleaning())
                                { speed, isCleaningOk ->
                                    spaceship.setOff(speed)
                                    isCleaningOk
                                }
                                .get()
                        )
                    }
                </code>
            </pre>
                <aside class="notes">
                    But... there always is a but :) This looks horrible for me. I mean look at this code!
                    Can you read it for the first time and see what it's doing? I don't even though I wrote it!
                    Calling this spaghetti code is like calling the whole where you to pee in a train a toilet.
                    I know that there are Pendolino trains, but they don't go to Lublin.
                    Let's try and make it slightly more bearable.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        fun initiateStart() {
                            val engineAndCleaningFuture = spaceship.startEngines()
                                .thenCombine(spaceship.startAutoCleaning())
                                { speed, isCleaningOk ->
                                    spaceship.setOff(speed)
                                    isCleaningOk
                                }
                            spaceship.reportCleaning(engineAndCleaningFuture.get())
                        }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="8"/>
                <p class="fragment" data-code-focus="5"/>
                <aside class="notes">
                    Let's try to clean this up a bit...
                    Second of all you really need to go deep into this combinators business. And I really don't want
                    that. I just wanted
                    to spin off some async tasks and not mess around with combinators. Now your async code looks
                    very different to your async code, which is not nice at all. You are also lucky if there is a
                    combinator for the problem you are facing and you can find it.
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3>Kotlin Coroutines</h3>
                <h3>to the rescue!</h3>
                <aside class="notes">
                    How is this going to help Mark not get blown up or how is this going to help you write code
                    you are familiar with?
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        suspend fun startEngines(): Int =
                            withContext(Dispatchers.IO) {
                                println("Starting engines")
                                delay(700)
                                190
                            }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="1"/>
                <aside class="notes">
                    We will first modify the the spaceship functions. Instead of using Completable
                    Futures they will be declared as suspending functions and will simply return their values.
                    However we don't want to only declare them as suspending, but we actually want to make them
                    suspending. What does that even mean?
                    A suspending function is simply a function which execution can be paused and resumed later
                    without blocking the calling thread. How is this done? These suspend functions are compiled
                    to functions with a callback parameter which is used to resume the execution of the function.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        fun startEngines(callback: Continuation&lt;Int&gt;): Int =
                            withContext(Dispatchers.IO) {
                                println("Starting engines")
                                delay(700)
                                190
                            }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="1">
                    <i>callback</i> is used to resume computation.
                </p>
                <aside class="notes"></aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        suspend fun autoClean(): Boolean =
                           withContext(Dispatchers.IO) {
                               println("Starting cleaning")
                               delay(500)
                               throw RuntimeException()
                           }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="2"/>
                <aside class="notes">
                    We also need to change the second function to a suspending function. But you're probably asking
                    yourself what is this withContext() function? This is the function that actually does the suspending
                    magic. It calls the given block, suspends until it completes and returns the result. It also takes
                    a coroutine context parameter, which here is a Dispatcher. Dispatchers describe how the computation
                    should be run. Because we know that our function is not CPU intensive and we just want to wait for
                    it, then we use the IO Dispatcher to offload the task to the shared pool of threads. This is what
                    we would use IO Dispatcher for, right? We have a blocking task, like reading from a file and
                    someone just needs to wait for the end. It's not a heavy computation, so we can possibly have many
                    of these and that's what the IO Dispatcher is. By default it has 64 threads unless you have more
                    cores than this.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                    suspend fun initiateStart() = coroutineScope {
                        val engineDeferred = async { suspendingShip.startEngines() }
                        val cleaningDeferred = async { suspendingShip.autoClean() }

                        println("Coroutines started!")

                        spaceship.setOff(engineDeferred.await())
                        spaceship.reportCleaning(cleaningDeferred.await())
                    }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="1"/>
                <p class="fragment" data-code-focus="2,3"/>
                <aside class="notes">
                    With Kotlin coroutines we can write the code like it was ordinary sequential code. We can almost go
                    back to our first attempt and this time it is going to be correct. It's very easy to write and
                    super readable. We keep almost the same logic, but wrap it in a coroutineScope and async modifiers.

                    Concurrency in Kotlin just like the entire language is very explicit. The way it works here is that
                    we create a CoroutineScope at the very top, which wraps all the computation that we want to
                    decompose in parallel.
                    I don't want to go super deep in here, but slightly simplifying:
                    This guy has two important properties: first of all by convention each scope waits for all its
                    children to finish, so that we can reason about it in a sequential manner. And second of all scopes
                    are used to propagate cancellation to its children not to leave any hanging computation.
                    We are allowed to launch coroutines only in a Coroutine Scope. Why? Because Kotlin wants us to run
                    the concurrent computation in a well-defined context. You often want to spin off some concurrent
                    computation only in a limited time frame and then clean up. This is what Coroutine Scope is
                    essentially for.
                    It is an entity with a well-defined lifecycle which is responsible for launching and cancelling
                    children coroutines.

                    Now: what are these coroutines and where are they? Well, they're right here! You can think of
                    coroutines as lightweight threads. So lightweight in fact that you should not be afraid creating
                    them, but you're actually encouraged to create many of them to structure your concurrent logic.
                    Which I guess is kind of exemplified by how easy it is to create and use them.

                    Async is an extension method on CoroutineScope. Don't worry if you don't know what that is. It
                    basically operates on the coroutine scope we created here. async{} creates a new coroutine and
                    it returns its future result as an implementation of Deferred, which is kind of Kotlin equivalent of
                    Java Future, but better. It's scoped like we can see here and CoroutineScope handles cancellation,
                    so Deferred is fail-safe. This is one of Kotlin coroutine builders and what they also do is they
                    create their own CoroutineScope, which allows them to launch their children computation.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        withContext {}
                        coroutineScope {}
                        async {}
                    </code>
                    <h3 class="fragment fade-in">They all create their own CoroutineScope</h3>
                </pre>
                <aside class="notes">
                    All coroutine builders and scoping functions (these special coroutine functions that we've seen)
                    create their own CoroutineScope. Let's not go too deep into the rabbit hole, but I hope you get the
                    idea.
                </aside>
            </section>
        </section>
        <section data-background-image="images/orion.jpg">
            <aside class="notes">
                We have helped Mark find the possible cause of Leto's I trouble and fix it. Moreover we gave him
                a standard, very nice, readable and foolproof solution for parallel decomposition of tasks. He's now
                safely off from Phobos continuing his mission. Mark is rather cautious after the first expedition
                disappeared mysteriously and doesn't want to fly straight to Mars. He would like first do a
                reconnaissance flight and check that everything is fine. He will
                first circle the Red Planet and collect some data from the spaceship's sensors to double-check that the
                vehicle has been prepared for the current conditions. If any of the readings is off the charts, then
                he will cancel the reconnaissance flight and go back to Phobos.
            </aside>
        </section>
        <section>
            <section>
                 <pre>
                    <code class="kotlin stretch" data-trim data-noescape>
                    private fun getTempReading(): SensorReading {
                        Thread.sleep(500) //sensor processing data
                        return SensorReading("temp", -270.1)
                    }<p class="fragment" data-code-focus="2"/>
                    <p class="fragment fade-in">
                    private fun getSolarReading(): SensorReading {
                        Thread.sleep(700) //sensor processing data
                        return SensorReading("sun", 372.0)
                    }
                    </p>
                    <p class="fragment fade-in">
                    fun getAllReadings(): List&lt;SensorReading&gt; = listOf(
                        getTempReading(),
                        getSolarReading()
                    )
                    </p>
                    </code>
                 </pre>
                <aside class="notes">
                    There are lots of sensors that will be collecting data. Here is the first
                    attempt that the engineers have put forward. We have a number of functions that will need to do some
                    work (this is simulated by the sleep). Then we have the second, similar function returning a
                    different reading and then finally we will return all these readings in a list.
                </aside>
            </section>
            <section data-background-image="images/rocks.jpg">
                <aside class="notes">
                    As the spaceship is flying around the planet we want the autopilot to correct the path to avoid
                    any obstacles that might be flying in the outer space.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin stretch" data-trim data-noescape>
                        fun main() = runBlocking {
                            launch {
                                for (i in 1..5) {
                                    println("Actively correcting path...")
                                    delay(500)
                                }
                            }
                            println("Waiting for the coroutine to launch...")
                            delay(500)
                        <p class="fragment" data-code-focus="2"/>
                        <p class="fragment" data-code-focus="8,9"/>
                        <p class="fragment fade-in">
                            println("Starting blocking measurements...")
                            val readings = SensorController.getAllReadings()
                            println(readings)
                            readings.forEach {
                                Thread.sleep(1000) //Mark's validation
                                println(it)
                            }
                        }
                        <p class="fragment" data-code-focus="14"/>
                        <p class="fragment" data-code-focus="17"/>
                        </p>
                    </code>
                 </pre>
                <aside class="notes">
                    We don't want this to be blocked so that we don't fly into NASA's rubbish.
                    Then we're going to take the measurements and Mark will validate
                    each of them before accepting it. The problem here is that taking the measurements will block the
                    main thread and also correcting the path.
                </aside>
            </section>
            <section>
                <video class="stretch" src="images/blocking.mov" controls></video>
                <aside class="notes">
                    So we're not actually doing what we were suggested to do. We want to process the items one by one.
                    Moreover we need to do it async without blocking the main thread. How can we do it? You've guessed
                    it: suspending functions.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin stretch" data-trim data-noescape>
                        private suspend fun getTempReadingSuspending(): SensorReading {
                            delay(500) //sensor processing data
                            return SensorReading("temp", -270.1)
                        }
                        <p class="fragment fade-in">
                        private suspend fun getSolarReadingSuspending(): SensorReading {
                            delay(700) //sensor processing data
                            return SensorReading("sun", 372.0)
                        }
                        </p>
                        <p class="fragment fade-in">
                        fun getAllReadingsInFlow(): Flow&lt;SensorReading&gt; = flow {
                            emit(getTempReadingSuspending())
                            emit(getSolarReadingSuspending())
                        }
                        </p>
                    </code>
                 </pre>
                <p class="fragment" data-code-focus="12"/>
                <p class="fragment" data-code-focus="13,14"/>
                <aside class="notes">
                    We turn the first two functions into suspending functions. And finally what is going to allow us
                    to process the items async one by one is a cold Flow.
                    Cold means that no resources are bound upon creation, once the collector finishes, no computation is
                    running
                    It only describes the computation, it's not started until a terminal operation is called.
                    First we create the flow from the suspendable block.
                    Then we emit items to it. It basically declares these values as being later available to the
                    collector when the collection eventually happens.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin stretch" data-trim data-noescape>
                        fun main() = runBlocking {
                            launch {
                                repeat (15) {
                                    println("Actively correcting path...")
                                    delay(500)
                                }
                            }
                            println("Waiting for the coroutine to launch...")
                            delay(500)
                        <p class="fragment fade-in">
                            println("Starting non-blocking measurements...")
                            val flow = SensorController.getAllReadingsInFlow()
                            println(flow)
                            flow.collect {
                                delay(1000) //Mark's validation
                                println(it)
                            }
                        }
                        </p>
                    </code>
                 </pre>
                <p class="fragment" data-code-focus="14"/>
                <aside class="notes">
                    So now if we use a flow instead of a list we should be able to keep correcting the path of the
                    spaceship while taking the measurements and validating them.
                    This is the terminal action that causes the flow to be evaluated. The block passed to collect {}
                    describes what should be done with each of the values that has been emitted in the flow.
                    Let's see how that looks.
                </aside>
            </section>
            <section>
                <video class="stretch" src="images/flows.mov" controls></video>
                <aside class="notes">
                    If you need to return multiple items from a suspending function, then Flow is the collection that
                    you
                    should be using.
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h2>RxKotlin?</h2>
                <aside class="notes">
                    Ok, nice, so we've basically got another RX implementation of lazy streams in Kotlin. Why should
                    Mark
                    care? Because it's quite different from how the Rx is implemented.
                    Because Mark is far in the outer space, far from Houston. It makes a whole world of a difference
                    if you can improve something in your toolbox yourself, if you can create another tool suitable for a
                    job and if you can understand what it's actually doing.
                </aside>
            </section>
            <section>
                <h3>"Be warned that writing (reactive) operators is hard..."</h3>
                <br>
                *from the ReactiveX documentation
                <aside class="notes">
                    If you've ever tried to write your own
                    implementation of RX operator, then you would know that it's actually pretty difficult to get
                    all the corner cases right. Why is it so difficult? Partly because we're trying to get async
                    backpressure on the JVM - the platform has no support for this. So you get a ton of operators, but
                    you're pretty much out of luck if none of them really suits you.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        interface Flow&lt;out T&gt; {
                           suspend fun collect(collector: FlowCollector&lt;T&gt;)
                        }
                        <p class="fragment fade-in">
                        interface FlowCollector&lt;in T&gt; {
                            suspend fun emit(value: T)
                        }
                        </p>
                    </code>
                </pre>
                <aside class="notes">
                    How is this different with Flows? Well, Flows again fit in nicely into the principles of the Kotlin
                    language. They are built upon suspending functions. That means that their design is pretty
                    straightforward and you basically get backpressure for free. It's handled by the suspending
                    functions.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                    suspend fun &lt;T&gt; Flow&lt;T&gt;.collect(action: suspend (value: T) -> Unit) =
                            collect(object : FlowCollector&lt;T&gt; {
                                        override suspend fun emit(value: T) = action(value)
                                        }
                                    )
                    </code>
                </pre>
                <aside class="notes">
                    All the actions that we execute on each of the items of the flows are suspendable. That means
                    that the entire flow is suspended until we start executing these actions in our terminal operator:
                    collect(). When these actions are executed though they will too be suspended when they take time
                    to complete and will only proceed to the next stage when ready.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                    fun Flow&lt;SensorReading&gt;.validateMeasurement(): Flow&lt;SensorReading&gt; =
                        transform { sensorReading ->
                            delay(1000) //delay moved from the collector
                            if (sensorReading.value > 1000) throw IllegalStateException()
                            emit(sensorReading)
                        }
                    </code>
                </pre>
                <p class="fragment" data-code-focus="2"/>
                <aside class="notes">
                    Applies transform function to each value of the given flow.
                    The receiver of the transform is FlowCollector and thus transform is a generic function that may
                    transform emitted element, skip it or emit it multiple times. This operator can be used as a
                    building block for other operators, for example:
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                    flow
                        .validateMeasurement()
                        .collect { println(it) }
                    </code>
                </pre>
                <aside class="notes">
                    You can use your custom operator on the flow that we've had before.
                    If you look at these flows maybe you notice a detail, which again is pretty important.
                    There are no subscriptions!
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                val originalFlow: Flow&lt;SensorReading&gt; =
                        SensorController.getAllReadingsInFlow()

                val validatedFlow: Flow&lt;SensorReading&gt; =
                        originalFlow.validateMeasurement()

                val unit: Unit =
                        validatedFlow.collect { println(it) }
                    </code>
                </pre>
                <aside class="notes">
                    You cannot leak a subscription. There is no such thing. It's super safe just like the coroutines
                    that help us manage computations with scopes.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-noescape>dataFlow()
<p class="fragment fade-in">    .sendMailOnInappropriateException()</p>
    .failAfterThree()
    .catch { e -> println("Caught exception $e") }
    .collect { println(it) }</code>
                </pre>
                <aside class="notes">
                    .catch only catches exception upstream to provide exception transparency: you don't catch the
                    exceptions of the entire stream.
                </aside>
            </section>
            <section>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        fun &lt;T&gt; Flow&lt;T&gt;.sendMailOnInappropriateException(): Flow&lt;T&gt;> =
                            catch { e ->
                                if (e is InappropriateException) println("Sending email...")
                            }
                    </code>
                </pre>
                <aside class="notes">
                    You can quite nicely encapsulate your exception handling logic.
                </aside>
            </section>
            <section>
                <h3>Coming later</h3>
                <pre>
                    <code class="kotlin" data-trim data-noescape>
                        SensorController.getAllReadingsInFlow().concurrent(4) {
                            collect { println(it) }
                        }<p class="fragment fade-in">.collect {}</p>
                    </code>
                </pre>
                <aside class="notes">
                    It would be nice to have concurrent processing of the flows and it is under way, but it's
                    actually only being designed.
                    It's going to collect in 4 coroutines concurrently
                    I don't like this particular design, because at the end you need to write an empty collect to
                    activate it all.
                </aside>
            </section>
        </section>
        <section>
            <section>
                <h3>Thanks for your attention!</h3>
                <aside class="notes">
                    My name is Krystian Rybarczyk
                    I came here from Lublin and I'm glad I could drive a car and not take a train.
                    I've worked quite a while in the JVM world
                    I work for Codete mostly remotely and I very much enjoy this style of work. And I recently switched
                    to
                    a project where the majority of the codebase is written in Kotlin, so that really sparked my
                    interest
                    in this language.
                </aside>
            </section>
            <section>
                <pre>
                <code class="html" data-trim data-noescape="">
                Code samples: https://github.com/krrybarc/coroutines-and-flows<br>
                Presentation: https://knrybarczyk.github.io/flows/<br><br>
                https://github.com/knrybarczyk<br>
                https://linkedin.com/in/krybarczyk/
                </code>
                    </pre>
            </section>
        </section>
    </div>
</div>

<script src="js/reveal.js"></script>

<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
			    progress: false,
			    history: true,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true },
					{ src: 'node_modules/reveal-code-focus/reveal-code-focus.js',
                      async: true,
                      callback: function() {
                        RevealCodeFocus();
                      }
                    }
				]
			});

</script>
</body>
</html>
